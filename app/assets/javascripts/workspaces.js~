String.prototype.reverse = function() {
    var s = "";
    var i = this.length;
    while (i>0) {
        s += this.substring(i-1,i);
        i--;
    }
    return s;
}
String.prototype.replaceAt = function(index, c) {
	  return this.substr(0, index) + c + this.substr(index+c.length);
}

// Element.addMethods({
//     show : function(element) {
//         element = $(element);
//         element.removeClassName('hidden') //should be enough to show Element, but 
//                .setStyle({display: ''}); //in case the element was hidden with inline script
//     },
//     hide : function(element) {
//         element = $(element);
//         element.addClassName('hidden'); //hide element with css                
//     }
// });

function showUpload(id) {
  Element.show(id+'.upload');
  Element.show(id+'.cancelbutton');
  Element.hide(id+'.addbutton');
}

function hideUpload(id) {
  Element.hide(id+'.upload');
  Element.hide(id+'.cancelbutton');
  Element.show(id+'.addbutton');
}

function insert_asset(divid,txt) {
  if ($(divid+'.assets')) {
    $(divid+'.assets').insert({bottom: txt});
  }
}

function delete_asset(divid,assetid) {
  if ($(divid+'.asset'+assetid)) {
    $(divid+'.asset'+assetid).remove()
  }
}

function create_workspace(txt) {
  if ($('comments')) $('comments').insert({ top: txt });
  sortWorkspaces();
}

function jug_ws_update(dv,txt) {
  if ($(dv)) {
    if ($(dv+'.editing')) {
      if ($(dv+'.conflict')) $(dv+'.conflict').update('<font style="color:red;font-weight:bold;">Edit Conflict!</font>');
    } else
      $(dv).update(txt);
    sortWorkspaces();
  }
}
  
function sortWorkspaces() {
  workspaces = $$('div.workspace');
  high = []
  normal = []
  useless = []
  other = []
  workspaces.each(function(ws) {
    fd = ws.firstDescendant();
    if (fd) {
      if (fd.hasClassName('priority_High')) high.push(ws);
      else if (fd.hasClassName('priority_Normal')) normal.push(ws);
      else if (fd.hasClassName('priority_Useless')) useless.push(ws);
      else other.push(ws);
    }
  });
  if ($('comments')) {
    $('comments').update();
    high.each(function(ws) { $('comments').insert({bottom:ws}); });
    normal.each(function(ws) { $('comments').insert({bottom:ws}); });
    other.each(function(ws) { $('comments').insert({bottom:ws}); });
    useless.each(function(ws) { $('comments').insert({bottom:ws}); });
  }
}

function fakemod(i,m) {
  if (i%m) return i%m;
  return m;
}


function ASC(s) {
	return s.charCodeAt(0);
}
function LET(s) {
	var n = ASC(s);
	if (n >= ASC("a") && n <= ASC("z")) return n - ASC("a") + 1;
	if (n >= ASC("A") && n <= ASC("Z")) return n - ASC("A") + 1;
	return 0;
}
function getField(V) {
  if (V.match(/-?[\d\.]+/)) return V;
  if (V.match(/\#/)) return currrow + 1;
  V = LET(V);
  if (V < 1 || V >= currtable.heads.length) return null;
  if (currtable.heads[V].match(/^=/))
  V = currtable.rows[currrow][V].calc.innerHTML;
  else
  V = currtable.rows[currrow][V].value;
  /* if (C == ":L")  V = String.fromCharCode(fakemod(parseInt(V),26)+64);
  if (C == ":l")  V = String.fromCharCode(fakemod(parseInt(V),26)+96);
  if (C == ":I")  { if (V.match(/[A-Z]/)) V = (V.charCodeAt(0)-65+1).toString(); else V=(V.charCodeAt(0)-97+1).toString();}
  if (C == ":b")  { V = parseInt(V,2).toString(); }
  if (C == ":B")  { V = parseInt(V.reverse(),2).toString(); } */
  return V;
}

function formulaElement(r,c,tinf) {
    tinf.rows[r][c].inp.hide();
    tinf.rows[r][c].calc.show();
}

var currtable;
var currrow;

function computeFormula(r,c,tinf) {
    normalElement(r,c,tinf);
    var formula = tinf.heads[c].substr(1);
    currtable = tinf;
    currrow = r;
    log("Trying the infix parser...");
    // okay, parse the formula.
    var V = infix_parse(formula);
    tinf.rows[r][c].calc.update(V);
    formulaElement(r,c,tinf);
}

function normalElement(r,c,tinf) {
    tinf.rows[r][c].calc.hide();
    tinf.rows[r][c].inp.show();
}

function init_table(table) {
  TableKit.Sortable.init(table, {});
  TableKit.Resizable.init(table, {});
}

function table_navigate(evt,i,j,len,id) {
  if ((evt.keyCode==13
    || evt.keyCode==40)
    && i < len-1) {
    $(id+'_'+(i+1)+'_'+j).focus();
  } else if (evt.keyCode == 38 && i > 0) {
    $(id+'_'+(i-1)+'_'+j).focus();
  }
}

function grid_navigate(evt,i,j,len,wid,id) {
log("navigating on grid.");
  if ((evt.keyCode==13
    || evt.keyCode==40)
    && i < len-1) {
    $(id+'_'+(i+1)+'_'+j).focus();
    $(id+'_'+(i+1)+'_'+j).select();
    return true;
  } else if (evt.keyCode == 38 && i > 0) {
    $(id+'_'+(i-1)+'_'+j).focus();
    $(id+'_'+(i-1)+'_'+j).select();
    return true;
  } else if (evt.keyCode == 37 && j > 0) {
    $(id+'_'+i+'_'+(j-1)).focus();
    $(id+'_'+i+'_'+(j-1)).select();
    return true;
  } else if (evt.keyCode == 39 && j < wid-1) {
    $(id+'_'+i+'_'+(j+1)).focus();
    $(id+'_'+i+'_'+(j+1)).select();
    return true;
  }
  return false;
}

function update_tables() {
 tables=$$('.pzt_table');
 tables.each(function(tid) { update_table(tid); });
}

function update_table(tid) {
  if ($(tid)) {
    var t=$(tid);
    tinf={}

    tinf.heads = t.select('th');
    tinf.heads.each(function(h,i) {
      if (!i) tinf.heads[i] = 0;
      else
      tinf.heads[i] = h.select('input')[0].value;
    });

    cells = t.select('td');
    tinf.rows=[];
    cells.each(function(cell,i) {
      var c=i%tinf.heads.length;
      var r=parseInt(i/tinf.heads.length);
      if (!tinf.rows[r]) tinf.rows[r] = [];
      tinf.rows[r][c] = { };
      if (!c) return;
      tinf.rows[r][c].value = cell.select('input')[0].value;
      tinf.rows[r][c].calc = cell.select('.calc')[0];
      tinf.rows[r][c].inp = cell.select('.inp')[0];
    });

    cells.each(function(cell,i) {
      var c=i%tinf.heads.length;
      var r=parseInt(i/tinf.heads.length);
      if (!c) return;
      if (tinf.heads[c].match(/^\=/)) {
         computeFormula(r,c,tinf);
      } else {
         normalElement(r,c,tinf);
      }
    });
  }
}

function update_table_cell(cid,txt,tid) {
	if (!$(cid)) return;
	$(cid).value = txt;
	update_table(tid);
}

grid_colors = { "!":"grid_black", "@":"grid_brown", "#":"grid_red", "$":"grid_orange", "%":"grid_yellow", "^":"grid_green", "&":"grid_blue", "*":"grid_purple" };

function update_grid_cell(cid,txt) {
	if (!$(cid)) return;
	a = txt.split(":");
	$(cid).value = a[0];
	for (var n in grid_colors) {
		$(cid).removeClassName(grid_colors[n]);
	}
	if (a[0].match(/^[\!\@\#\$\%\^\&\*]/)) $(cid).addClassName(grid_colors[a[0]]);
	if (a.length > 1) {
	label = $(cid).previous();
	label.innerHTML = a[1];
	}

}

function gcell_value(cid) {
	return $(cid).getValue() + ':' + $(cid).previous().innerHTML;
}

function grid_set_label(evt,cid,id) {
	if (!evt.shiftKey) return false;
	if (!$(cid)) return false;
	var label = $(cid).previous();
	var name = prompt("Label for this cell", label.innerHTML);
	if (name == null) return true;
	if (name.match(/[A-Z0-9]*/)) {
		// it is a valid label. Set it.
		v = $(cid).getValue() + ':' + name;
		new Ajax.Request('/workspace/update_cell?cell='+cid+'&id='+id, {asynchronous:true, evalScripts:true, parameters: { text: v } });
	}
	return true;
}

// okay, this is an infix parser. Its goal is to be able to parse a message to do operations on columns.
// E.g., (C@(A+B):I+A[C]:I):L
// Just so we can continue to use shunting yard, we're going to do this:
// A[blah] => A$(blah), with $ as a high-precedence operator.
function infix_parse(s) {
	// evaluate a properly-formed expression in infix notation
	var output = [];
	var stack = [];
	// check for negatives first?
	var cn=true;
	var token;
	var precedence = { "$":4, ":":3, "@":2, "/":1, "*":1, "+":0, "-":0 };
	if (!s || !s.length) return 0;
	while (token=get_token(s,cn)) {
		s = token[1];
		if (token[2] == 1) {
			// first get the field value here.
			// now wait - if your last token was :, don't getField.
			if (stack[stack.length-1] == ":")
			output.push(token[0]);
			else
			output.push(getField(token[0])); cn = false;
		} else if (token[0] == '(') {
			stack.push(token[0]); cn = true;
		} else if (token[0] == ')') {
			cn = false;
			while (stack.length && stack[stack.length-1] != '(') {
				output.push(stack.pop());
			}
			if (!stack.length) return 0;
			stack.pop();
		} else {
			// you are an operator
			if (token[2] == 2) {
				log("Faking $ operator");
				output.push(getField(token[0]));
				token[0] = '$';
			}
			while (stack.length 
				&& stack[stack.length-1].match(/[\+\*\-\/\:\@\$]/)
				&& precedence[stack[stack.length-1]] >= precedence[token[0]]) {
				output.push(stack.pop());
			}
			stack.push(token[0]);
			cn = true;
		}
	}
	log("Stack is "+stack.join(","));
	log("Output is "+output.join(","));
	while (stack.length) {
		if (stack[stack.length-1] == '(') {
			return 0;
		}
		output.push(stack.pop());
	}

	log("Doing RPN");

	for (i=0;i<output.length;i++) {
		// push everything on the stack that isn't an operator
		if ((typeof output[i] == "string") && output[i].match(/[\+\*\-\/\:\@\$]/)) {
			log("Operator is "+output[i]);
			var x1 = stack.pop();
			var x2 = stack.pop();
			if (output[i] == '*') stack.push(asInt(x2)*asInt(x1));
			if (output[i] == '/') stack.push(asInt(x2)/asInt(x1));
			if (output[i] == '+') stack.push(asInt(x2)+asInt(x1));
			if (output[i] == '-') stack.push(asInt(x2)-asInt(x1));
			if (output[i] == ':') stack.push(cast(x2,x1));
			if (output[i] == '@') stack.push(rot(x2,x1));
			if (output[i] == '$') stack.push(ind(x2,x1));
			log("Pushed "+stack[stack.length-1]);
		} else {
			stack.push(output[i]);
		}
	}
	return stack[0];
}

function asInt(n) {
	// it is some kind of string.
	return parseFloat(n);
}

function cast(a,b) {
	if (b == "I") {
		return LET(a);
	}
	if (b == "B") return parseInt(a.reverse(),2);
	if (b == "b") return parseInt(a,2);
	if (b == "L") return String.fromCharCode(fakemod(parseInt(a),26)+64);
	if (b == "l") return String.fromCharCode(fakemod(parseInt(a),26)+96);
	if (b == "R") return a.reverse();
	return 0;
}

function rot(a,b) {
	var r = "";
	var i;
	for (i=0;i<a.length;i++) {
	 r += String.fromCharCode(fakemod(LET(a[i])-1 + parseInt(b),26)+65);
	}
	return r;
}

function ind(a,b) {
	log("Trying to index..."+a+" "+b);
	return a.replace(/[^A-Za-z]/g,'').substr(parseInt(b)-1,1);
}

function get_token(s,cn) {
	var i = 0;
	log("Parsing {"+s+"}");
	if (!s || !s.length) return null;
	if (!cn && s.match(/^[\+\*\/\(\-\)]/)) {
		return [s.slice(0,1),s.slice(1),0];
	}
	if (s.match(/^\-?[0-9]+\.?[0-9]*/)) {
		if (s.match(/^[\-]/)) i++;
		while (i < s.length && s[i].match(/[0-9\.]/)) i++;
		var token = s.slice(0,i);
		return [token, s.slice(i),1];
	}
	if (s.match(/^[A-Za-z\#]+([^A-Za-z\#\(\[]|$)/)) {
		while (i < s.length && !s[i].match(/[^A-Za-z\#\(]/)) i++;
		// it's just a string. return it.
		token = s.slice(0,i);
		return [token,s.slice(i),1];
	}
	if (s.match(/^[A-Za-z]+\(/)) {
		while (s[i] != '(') i++;
		// find the match
		var nest = 1;
		while (nest) {
			if (s[++i] == '(') nest ++;
			if (s[i] == ')') nest--;
		}
		token = s.slice(0,i+1);
		return [0,s.slice(i+1),1];
	}
	if (s.match(/^[A-Z]\[/)) {
		s = s.replaceAt(1,'(');
		var nest = 1;
		while (nest) {
			if (s[++i] == '[') nest ++;
			if (s[i] == ']') nest--;
		}
		s = s.replaceAt(i,')');
		token = s.slice(0,1);
		return [token,s.slice(1),2];
	}
	if (s.match(/^[\+\*\/\(\-\)\^\:\@]/)) {
		return [s.slice(0,1),s.slice(1),0];
	}
	log("Improper token "+s+"!");
	return null;
}
